##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = '0.02';
pp_setversion($VERSION);

##------------------------------------------------------
## pm additions
pp_addpm({At=>'Top'},<<'EOPM');

use strict;

=pod

=head1 NAME

PDL::Ngrams::ngutils - Basic N-Gram utilities for PDL: low-level utilities

=head1 SYNOPSIS

 use PDL;
 use PDL::Ngrams::ngutils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr(<<'EOH');
EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Vector-Based Run-Length Encoding and Decoding
##======================================================================

pp_addpm(<<'EOPM');

=pod

=head1 Vector-Based Run-Length Encoding and Decoding

=cut

EOPM

##------------------------------------------------------
## rlevec()
pp_def('rlevec',
       Pars => 'c(M,N); int [o]a(N); [o]b(M,N)',
       Code =><<'EOC',
  int cn,bn=0, sn=$SIZE(N), matches;
  loop (M) %{ $b(N=>0)=$c(N=>0); %}
  $a(N=>0) = 1;
  for (cn=1; cn<sn; cn++) {
     matches=1;
     loop (M) %{
       if ($c(N=>cn) != $b(N=>bn)) {
         matches=0;
         break;
       }
     %}
     if (matches) {
       $a(N=>bn)++;
     } else {
       bn++;
       loop (M) %{ $b(N=>bn) = $c(N=>cn); %}
       $a(N=>bn) = 1;
     }
   }
   for (bn++; bn<sn; bn++) {
     $a(N=>bn) = 0;
     loop (M) %{ $b(N=>bn) = 0; %}
   }
EOC
       Doc =><<'EOD',
Run-length encode a set of vectors.

Akin to a higher-order rle(), for use with qsortvec().

Given set of vectors $c, generate a vector $a with the number of occurrences of each element
(where an "element" is a vector of length $M ocurring in $c),
and a set of vectors $b containing the unique values.
As for rle(), only the elements up to the first instance of 0 in $a should be considered.

Can be used together with clump() to run-length encode "values" of arbitrary dimensions.
Can be used together with rotate(), cat(), append(), and qsortvec() to count N-grams
over a 1d PDL.

See also: PDL::Slices::rle, PDL::Ufunc::qsortvec, PDL::Primitive::uniqvec

EOD

);


##------------------------------------------------------
## rldvec()
pp_def('rldvec',
       Pars => 'int a(N); b(M,N); [o]c(M,N)',
       PMCode=><<'EOC',
sub PDL::rldvec {
  my ($a,$b) = @_; 
  my ($c);
  if ($#_==2) { $c=$_[2]; }
  else {
# XXX Need to improve emulation of threading in auto-generating c
    my ($rowlen) = $b->dim(0);
    my ($size) = $a->sumover->max;
    my (@dims) = $a->dims;
    shift(@dims);
    $c = $b->zeroes($b->type,$rowlen,$size,@dims);
  }
  &PDL::_rldvec_int($a,$b,$c);
  return $c;
}
EOC
       Code =><<'EOC',
  int i,nrows,bn,cn=0, sn=$SIZE(N);
  for (bn=0; bn<sn; bn++) {
    nrows = $a(N=>bn);
    for (i=0; i<nrows; i++) {
      loop (M) %{ $c(N=>cn) = $b(N=>bn); %}
      cn++;
    }
   }
EOC
       Doc =><<'EOD'
Run-length decode a set of vectors, akin to a higher-order rld().

Given a vector $a() of the number of occurrences of each row, and a set $c()
of row-vectors each of length $M, run-length decode to $c().

Can be used together with clump() to run-length decode "values" of arbitrary dimensions.

See also: PDL::Slices::rld.

EOD

  );


##======================================================================
## Delimiter Insertion and Removal
##======================================================================

pp_addpm(<<'EOPM');

=pod

=head1 Delimiter Insertion and Removal

=cut

EOPM

##------------------------------------------------------
## ng_delimit()
pp_def('ng_delimit',
       Pars       => 'toks(NToks); int boffsets(NBlocks); delims(NDelims); [o]dtoks(NDToks)',
       #OtherPars  => 'int ndtoks => NDToks',
       PMCode=>
<<'EOPC',
sub PDL::ng_delimit {
  my ($toks,$boffsets,$delims,$dtoks,$ndtoks) = @_;
  barf('Usage: ng_delimit(toks(NToks), int boffsets(NBlocks), delims(NDelims), [o]dtoks(NDToks), ndtoks=>NDToks)')
    if (grep {!defined($_)} ($toks,$boffsets,$delims));
  ##
  ##-- basic data
  my @tokdims  = $toks->dims;
  my $NToks    = shift(@tokdims);
  my $NBlocks  = $boffsets->dim(0);
  my $NDelims  = $delims->dim(0);
  ##
  ##-- $ndtoks: maybe compute number of delimiters+tokens
  $ndtoks = $NToks + ($NBlocks * $NDelims)
    if ((!defined($dtoks) || $dtoks->isempty) && (!defined($ndtoks) || $ndtoks <= 0));
  ##
  ##-- $dtoks: maybe allocate
  $dtoks  = $toks->zeroes($toks->type, $ndtoks,@tokdims)
    if (!defined($dtoks) || $dtoks->isempty);
  ##
  ##-- underlying low-level call
  &PDL::_ng_delimit_int($toks,$boffsets,$delims,$dtoks);
  return $dtoks;
}
EOPC
       Code =>
<<'EOC',
 int szNToks=$SIZE(NToks), szNBlocks=$SIZE(NBlocks), szNDelims=$SIZE(NDelims), szNDToks=$SIZE(NDToks);
 int blocki=0,toki=0,dtoki=0,delimi;
 int nextBlockToki = $boffsets(NBlocks=>0);
 while (toki < szNToks) {
   while (toki==nextBlockToki) {
     //-- block boundary: insert delimiters
     for (delimi=0; delimi<szNDelims && dtoki<szNDToks; delimi++,dtoki++) {
       $dtoks(NDToks=>dtoki) = $delims(NDelims=>delimi);
     }
     //-- lookup next block boundary
     blocki++;
     if (blocki < szNBlocks) { nextBlockToki = $boffsets(NBlocks=>blocki); } //-- usual case
     else                    { nextBlockToki = szNToks; }                    //-- final block
   }
   //-- non-empty block: add tokens in this block
   for (; toki<nextBlockToki && toki<szNToks && dtoki<szNDToks; toki++,dtoki++) {
     $dtoks(NDToks=>dtoki) = $toks(NToks=>toki);
   }
 }
 //-- end of tokens: set any remaining dtoks to cyclic delimiters, for consistency
 for (delimi=0; dtoki<szNDToks; dtoki++,delimi++) {
   delimi %= szNDelims;
   $dtoks(NDToks=>dtoki) = $delims(NDelims=>delimi);
 }
EOC
       Doc =><<'EOD',
Add block-delimiters to a raw token vector

Splices the vector $delims into the vector $toks starting at each index
listed in $boffsets, returning the result as $dtoks.  Values in $boffsets
should be in the range [0..N-1].

For consistency, it should be the case that:

  $NDToks == $NToks + $NBlocks * $NDelims

EOD

);

##------------------------------------------------------
## ng_undelimit()
pp_def('ng_undelimit',
       Pars       => 'dtoks(NDToks); int boffsets(NBlocks); int NDelims(); [o]toks(NToks);',
       PMCode=>
<<'EOPC',
sub PDL::ng_undelimit {
  my ($dtoks,$boffsets,$NDelims,$toks) = @_;
  barf('Usage: ng_delimit(dtoks(NDToks), int boffsets(NBlocks), NDelims(), [o]toks(NToks))')
    if (grep {!defined($_)} ($dtoks,$boffsets,$NDelims));
  ##
  ##-- $toks: maybe allocate
  if (!defined($toks) || $toks->isempty) {
    $NDelims     = PDL->topdl($NDelims);
    my @dtokdims = $dtoks->dims;
    my $NDToks   = shift(@dtokdims);
    my $NBlocks  = $boffsets->dim(0);
    my $NToks    = $NDToks - ($NDelims->max * $NBlocks);
    $toks        = zeroes($dtoks->type, $NToks,@dtokdims);
  }
  ##
  ##-- underlying low-level call
  &PDL::_ng_undelimit_int($dtoks,$boffsets,$NDelims, $toks);
  return $toks;
}
EOPC
       Code=>
<<'EOC',
 int szNToks=$SIZE(NToks), szNBlocks=$SIZE(NBlocks), szNDToks=$SIZE(NDToks), szNDelims=$NDelims();
 int blocki=0,toki=0,dtoki=0,delimi;
 int nextBlockToki = $boffsets(NBlocks=>0);
 while (dtoki < szNDToks) {
   while (toki==nextBlockToki) {
     //-- block boundary: skip delimiters
     for (delimi=0; delimi<szNDelims && dtoki<szNDToks; delimi++,dtoki++) { ; }
     //
     //-- lookup next block boundary
     blocki++;
     if (blocki < szNBlocks) { nextBlockToki = $boffsets(NBlocks=>blocki); } //-- usual case
     else                    { nextBlockToki = szNToks; }                    //-- final block
   }
   //-- non-empty block: add tokens in this block
   for (; toki<nextBlockToki && toki<szNToks && dtoki<szNDToks; toki++,dtoki++) {
     $toks(NToks=>toki) = $dtoks(NDToks=>dtoki);
   }
 }
 //-- end of dtoks: set any remaining toks to 0
 for (; toki<szNToks; toki++) {
   $toks(NToks=>toki) = 0;
 }
EOC
       Doc =><<'EOD',
Remove block-delimiters from a delimited token vector.

Removes chunks of length $delims from the vector $toks starting at each index
listed in $boffsets, returning the result as $toks.  Values in $boffsets
should be in the range [0..N-1].

EOD
);

##======================================================================
## qsortvec drop-in replacement
##  + adopted from patched $PDL_SRC_ROOT/Basic/Ufunc/ufunc.pd
##======================================================================


# Internal utility sorting routine for median/qsort/qsortvec routines.
#
# note: we export them to the PDL Core structure for use in
#       other modules (eg Image2D)

foreach (keys %PDL::Types::typehash) {
    my $ctype = $PDL::Types::typehash{$_}{ctype};
    my $ppsym = $PDL::Types::typehash{$_}{ppsym};

    pp_addhdr(<<"FOO"

	/*******
         * qsortvec helper routines
	 *   --CED 21-Aug-2003
	 */

	/* Compare a vector in lexicographic order, returning the
	 *  equivalent of "<=>". 
 	 */
      signed char pdl_ngcmpvec_$ppsym($ctype *a, $ctype *b, int n) {
	int i;
	for(i=0; i<n; a++,b++,i++) {
	 if( *a < *b ) return -1;
	 if( *a > *b ) return 1;
	}
	return 0;
     }	

      void pdl_ngqsortvec_$ppsym($ctype *xx, int n, int a, int b) {

	int i,j, median_ind;

	$ctype t;
	i = a; 
	j = b;

	median_ind = (i+j)/2;

	do {
	  while( pdl_ngcmpvec_$ppsym( &(xx[n*i]), &(xx[n*median_ind]), n )  <  0 ) 
		i++;
	  while( pdl_ngcmpvec_$ppsym( &(xx[n*j]), &(xx[n*median_ind]), n )  >  0 ) 
		j--;
	  if(i<=j) {
		int k;
		$ctype *aa = &xx[n*i];
	        $ctype *bb = &xx[n*j];
		for( k=0; k<n; aa++,bb++,k++ ) {
		  $ctype z;
		  z = *aa;
		  *aa = *bb;
		  *bb = z;
		}

                if (median_ind==i)
                  median_ind=j;
                else if (median_ind==j)
                  median_ind=i;

	        i++; 
		j--;
	  }
	} while (i <= j);

	if (a < j)
	  pdl_ngqsortvec_$ppsym( xx, n, a, j );
	if (i < b)
	  pdl_ngqsortvec_$ppsym( xx, n, i, b );
      }

FOO
	     );
}

# when copying the data over to the temporary array,
# ignore the bad values and then only send the number
# of good elements to the sort routines
#

sub generic_ngqsortvec {
    my $pdl = shift;
    my $ndim = shift;
    return '$TBSULQFD(pdl_ngqsortvec_B,pdl_ngqsortvec_S,pdl_ngqsortvec_U,
             pdl_ngqsortvec_L,pdl_ngqsortvec_Q,pdl_ngqsortvec_F,pdl_ngqsortvec_D) ($P(' . $pdl . '), '. $ndim.', 0, nn);';
}

pp_def(
    '_ng_qsortvec',
    HandleBad => 1,
    Pars => 'a(n,m); [o]b(n,m);',
    Code => 
    'int nn;
     int nd;
     loop(n,m) %{ $b() = $a(); %}
     nn = ($COMP(__m_size))-1;
     nd = $COMP(__n_size);
    ' . generic_ngqsortvec('b','nd'),
    Doc => '
=for ref

Drop-in replacement for qsortvec(),
which is broken in the stock PDL-2.4.3 release.
',
    BadDoc =>
'
Vectors with bad components should be moved to the end of the array:
',
    ); # pp_def ngqsortvec


##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

Code for rlevec() and rldvec() derived from the PDL builtin functions
rle() and rld() in Basic/Slices/slices.pd.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2007, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
